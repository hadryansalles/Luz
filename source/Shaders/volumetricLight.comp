#version 450

#extension GL_GOOGLE_include_directive : enable

#include "LuzCommon.h"

layout(push_constant) uniform _constants {
    VolumetricLightConstants ctx;
};

layout (local_size_x = 32, local_size_y = 32) in;

// todo: put in some header
vec3 DepthToWorld(vec2 screenPos, float depth) {
    vec4 clipSpacePos = vec4(screenPos*2.0 - 1.0, depth, 1.0);
    vec4 viewSpacePos = sceneBlock.inverseProj*clipSpacePos;
    viewSpacePos /= viewSpacePos.w;
    vec4 worldSpacePos = sceneBlock.inverseView*viewSpacePos;
    return worldSpacePos.xyz;
}

void main() {
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    if (pixelPos.x >= ctx.imageSize.x || pixelPos.y >= ctx.imageSize.y) {
        return;
    }
    vec2 pixelUV = pixelPos / vec2(ctx.imageSize);
    float pixelDepth = texture(textures[ctx.depthRID], pixelUV).r;
    vec3 radiance = vec3(0);
    for (int i = 0; i < sceneBlock.numLights; i++) {
        LightBlock light = sceneBlock.lights[i];

        vec4 lightWorldPos = sceneBlock.projView * vec4(light.position, 1);
        vec2 lightUV = (lightWorldPos.xy / lightWorldPos.w) * 0.5 + vec2(0.5);

        // light is out of screen space
        if (lightUV.x < 0.0 || lightUV.y < 0.0 || lightUV.x >= 1.0 || lightUV.y >= 1.0) {
            continue;
        }

        float weight = 0.0002;
        int samples = 128; // todo: push constants
        float decay = 1.0;
        float density = 1.094;
        vec2 deltaUV = (pixelUV - lightUV) * density * (1.0 / float(samples));
        vec2 sampleUV = pixelUV;
        for (int i = 0; i < samples; i++) {
            sampleUV -= deltaUV;
            if (texture(textures[ctx.depthRID], sampleUV).r == 1.0) {
                radiance += light.color * light.intensity * weight * decay;
            }
            decay *= 1.0;
        }
    }
    vec4 rgba = imageLoad(images[ctx.lightRID], pixelPos);
    rgba += vec4(radiance, 0);
    imageStore(images[ctx.lightRID], pixelPos, rgba);
}

/*

float4 mainaa(float2 texCoord : TEXCOORD0) : COLOR0 {
  // Calculate vector from pixel to light source in screen space.
  half2 deltaTexCoord = (texCoord - ScreenLightPos.xy);
  // Divide by number of samples and scale by control factor.   
  deltaTexCoord *= 1.0f / NUM_SAMPLES * Density; // Store initial sample.half3 
  color = tex2D(frameSampler, texCoord); // Set up illumination decay factor.half 
  illuminationDecay = 1.0f;       // Evaluate summation from Equation 3 NUM_SAMPLES iterations.
  for (int i = 0; i < NUM_SAMPLES;
            i++) { // Step sample location along ray.     texCoord -=
    deltaTexCoord; // Retrieve sample at new location.    half3 sample =
    tex2D(frameSampler, texCoord); // Apply sample attenuation scale/decay
    factors.sample *= illuminationDecay * Weight; // Accumulate combined
    color.color += sample; // Update exponential decay factor.
    illuminationDecay *= Decay;
  } // Output final color with a further scale
  control factor.return float4(color * Exposure, 1);
}
*/