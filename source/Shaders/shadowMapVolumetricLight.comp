#version 450

#extension GL_GOOGLE_include_directive : enable

#include "LuzCommon.h"

layout(push_constant) uniform _constants {
    VolumetricLightConstants ctx;
};

#include "utils.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

float EvaluateShadow(LightBlock light, vec3 samplePos) {
    if (light.type == LIGHT_TYPE_DIRECTIONAL) {
        vec4 sampleInLight = (light.viewProj[0] * vec4(samplePos, 1));
        float shadowDepth = texture(textures[light.shadowMap], (sampleInLight.xy * 0.5 + vec2(0.5f, 0.5f))).r;
        if (sampleInLight.z >= shadowDepth) {
            return 1.0f;
        } else {
            return 0.0f;
        }
    } else {
        vec3 lightToFrag = samplePos - light.position;
        float shadowDepth = texture(cubeTextures[light.shadowMap], lightToFrag).r;
        if (length(lightToFrag) - 0.05 >= shadowDepth * light.zFar) {
            return 1.0f;
        } else {
            return 0.0f;
        }
    }
}

void main() {
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    if (pixelPos.x >= ctx.imageSize.x || pixelPos.y >= ctx.imageSize.y) {
        return;
    }

    vec2 pixelUV = pixelPos / vec2(ctx.imageSize);
    float pixelDepth = texture(textures[ctx.depthRID], pixelUV).r;
    vec3 worldPos = DepthToWorld(pixelUV, pixelDepth);
    vec3 camPos = scene.camPos;
    vec3 radiance = vec3(0);

    for (int i = 0; i < scene.numLights; i++) {
        LightBlock light = scene.lights[i];
        if (light.volumetricType != VOLUMETRIC_TYPE_SHADOW_MAP) {
            continue;
        }

        float weight = light.volumetricWeight;
        int samples = light.volumetricSamples;
        float decay = light.volumetricAbsorption;
        float density = light.volumetricDensity;

        // Calculate ray direction and length
        vec3 rayDir = normalize(worldPos - camPos);
        float rayLength = length(worldPos - camPos);
        float stepSize = rayLength / float(samples);

        // Add noise offset to starting position to reduce banding
        vec3 samplePos = camPos + BlueNoiseSample(0, pixelPos).r * stepSize * rayDir;
        
        float transmittance = 1.0;
        for (int i = 0; i < samples; i++) {
            // March along ray
            samplePos += stepSize * rayDir;
            
            // Sample shadow map
            float shadow = EvaluateShadow(light, samplePos);
            
            // Calculate in-scattering at this point
            float scattering = (1.0 - shadow) * density;
            
            // Calculate distance attenuation for point/spot lights
            float attenuation = 1.0;
            if (light.type != LIGHT_TYPE_DIRECTIONAL) {
                float dist = length(samplePos - light.position);
                attenuation = 1.0 / (dist * dist);
            }
            
            // Accumulate light contribution with Beer-Lambert absorption and distance attenuation
            radiance += transmittance * scattering * light.color * light.intensity * weight * attenuation;
            
            // Update transmittance with exponential decay
            transmittance *= exp(-decay * stepSize);
            
            // Early exit if transmittance gets too low
            if (transmittance < 0.01) {
                break;
            }
        }
    }
    vec4 rgba = imageLoad(images[ctx.lightRID], pixelPos);
    rgba += vec4(radiance, 0);
    imageStore(images[ctx.lightRID], pixelPos, rgba);
}