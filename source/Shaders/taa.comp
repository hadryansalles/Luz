#version 450

#extension GL_GOOGLE_include_directive : enable

#include "LuzCommon.h"

layout(push_constant) uniform Constants {
    PostProcessingConstants ctx;
};

#include "utils.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

vec2 get_motion_vector(float depth, ivec2 pos) {
    vec2 texCoord = (vec2(pos) + 0.5) / vec2(imageSize(images[ctx.lightInputRID]));
    vec3 worldPos = DepthToWorld(texCoord, depth);

    vec4 previousNDC = scene.prevViewProj * vec4(worldPos, 1.0);
    vec4 currentNDC = scene.viewProj * vec4(worldPos, 1.0);

    previousNDC.xyz /= previousNDC.w;
    currentNDC.xyz /= currentNDC.w;

    return ((currentNDC.xy - scene.jitter) - (previousNDC.xy - scene.prevJitter)) * vec2(0.5, 0.5);
}

void main() {
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    ivec2 size = imageSize(images[ctx.lightInputRID]);

    if (any(greaterThanEqual(pixelPos, size))) {
        return;
    }

    vec3 sourceSampleTotal = vec3(0.0);
    float sourceSampleWeight = 0.0;
    vec3 neighborhoodMin = vec3(10000);
    vec3 neighborhoodMax = vec3(-10000);
    vec3 m1 = vec3(0.0);
    vec3 m2 = vec3(0.0);
    float closestDepth = 10000;
    ivec2 closestDepthPos = ivec2(0);

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            ivec2 samplePos = pixelPos + ivec2(x, y);
            samplePos = clamp(samplePos, ivec2(0), size - ivec2(1));
            vec3 neighbor = max(vec3(0, 0, 0), imageLoad(images[ctx.lightInputRID], samplePos).rgb);

            float subSampleDistance = length(vec2(x, y));
            float subSampleWeight = MitchellFilter(subSampleDistance);

            sourceSampleTotal += neighbor * subSampleWeight;
            sourceSampleWeight += subSampleWeight;

            neighborhoodMin = min(neighborhoodMin, neighbor);
            neighborhoodMax = max(neighborhoodMax, neighbor);

            m1 += neighbor;
            m2 += neighbor * neighbor;

            float currentDepth = imageLoad(images[ctx.depthRID], samplePos).r;
            if (currentDepth < closestDepth) {
                closestDepth = currentDepth;
                closestDepthPos = samplePos;
            }
        }
    }

    vec3 sourceSample = sourceSampleTotal / sourceSampleWeight;
    vec2 motionVector = get_motion_vector(closestDepth, closestDepthPos);
    vec2 historyTexCoord = (vec2(pixelPos) + 0.5) / vec2(size) - motionVector;

    if (clamp(historyTexCoord, vec2(0), vec2(1)) != historyTexCoord) {
        imageStore(images[ctx.lightOutputRID], pixelPos, vec4(sourceSample, 1.0));
        return;
    }

    // vec3 historySample = SampleTextureCatmullRom(textures[ctx.lightHistoryRID], historyTexCoord).rgb;
    vec3 historySample = texture(textures[ctx.lightHistoryRID], historyTexCoord).rgb;

    // float oneDividedBySampleCount = 1.0 / 9.0;
    // float gamma = 1.0;
    // vec3 mu = m1 * oneDividedBySampleCount;
    // vec3 sigma = sqrt(abs((m2 * oneDividedBySampleCount) - (mu * mu)));
    // vec3 minc = mu - gamma * sigma;
    // vec3 maxc = mu + gamma * sigma;

    historySample = clip_aabb(neighborhoodMin, neighborhoodMax, sourceSample, historySample);
    // historySample = clamp(historySample, neighborhoodMin, neighborhoodMax);

    float sourceWeight = 0.05;
    // float historyWeight = 1.0 - sourceWeight;
    // vec3 compressedSource = sourceSample * rcp(max(max(sourceSample.r, sourceSample.g), sourceSample.b) + 1.0);
    // vec3 compressedHistory = historySample * rcp(max(max(historySample.r, historySample.g), historySample.b) + 1.0);
    // float luminanceSource = Luminance(compressedSource);
    // float luminanceHistory = Luminance(compressedHistory);

    // sourceWeight *= 1.0 / (1.0 + luminanceSource);
    // historyWeight *= 1.0 / (1.0 + luminanceHistory);

    // vec3 result = (sourceSample * sourceWeight + historySample * historyWeight) / max(sourceWeight + historyWeight, 0.00001);

    vec3 result = sourceSample * sourceWeight + historySample * (1.0 - sourceWeight);

    imageStore(images[ctx.lightOutputRID], pixelPos, vec4(result, 1.0));
}