#version 450

#extension GL_GOOGLE_include_directive : enable

#include "LuzCommon.h"

layout(push_constant) uniform _constants {
    LineRenderingConstants ctx;
};

layout (local_size_x = 32) in;

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id > ctx.lineCount) {
        return;
    }
    LineBlock line = lineBlocks[id];

    vec4 p0 = scene2.projView * vec4(line.p0, 1.0);
    p0 /= p0.w;
    p0.xy = (p0.xy + 1.0) * 0.5;
    vec4 p1 = scene2.projView * vec4(line.p1, 1.0);
    p1 /= p1.w;
    p1.xy = (p1.xy + 1.0) * 0.5;

    int x0 = int(p0.x * ctx.imageSize.x);
    int y0 = int(p0.y * ctx.imageSize.y);
    int x1 = int(p1.x * ctx.imageSize.x);
    int y1 = int(p1.y * ctx.imageSize.y);
    float thickness = 1;

    int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);
    int sx = (x0 < x1) ? 1 : -1;
    int sy = (y0 < y1) ? 1 : -1; 
    int err = dx - dy;

    vec2 direction = normalize(vec2(x1 - x0, y1 - y0));
    vec2 perp = vec2(-direction.y, direction.x) * thickness * 0.5;

    while (true) {
        for (float t = -thickness * 0.5; t <= thickness * 0.5; t++) {
            vec2 offset = perp * t;
            int offsetX = int(offset.x);
            int offsetY = int(offset.y);
            ivec2 pixelPos = ivec2(x0 + offsetX, y0 + offsetY);
            imageStore(images[ctx.outputRID], pixelPos, vec4(line.color));
        }

        if (x0 == x1 && y0 == y1) break;
        int e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x0 += sx; }
        if (e2 < dx) { err += dx; y0 += sy; }
    }
}